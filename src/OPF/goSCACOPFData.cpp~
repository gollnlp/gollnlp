#include "goSCACOPFData.hpp"

#include "goLogger.hpp"
#include <cstdlib>
#include <cassert>

#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <algorithm>
using namespace std;

namespace gollnlp {

//temporary log object
goLogger log(stdout);

goSCACOPFData::goSCACOPFData()
{
  
}

// trim from start (in place)
static inline void ltrim(std::string &s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(),
            std::not1(std::ptr_fun<int, int>(std::isspace))));
}

// trim from end (in place)
static inline void rtrim(std::string &s) {
    s.erase(std::find_if(s.rbegin(), s.rend(),
            std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
}

// trim from both ends (in place)
static inline void trim(std::string &s) {
    ltrim(s);
    rtrim(s);
}

static vector<string> split (const string &s, char delim) {
  vector<string> result;
  stringstream ss(s);
  string item;
  
  while (getline (ss, item, delim)) result.push_back (item);
  
  return result;
}

inline bool isEndOfSection(const string& l)
{
  if(l.size()==0) return false;
  if(l[0] != '0' && l[0] != ' ') return false;
  if(l.size() == 1 && l[1] == '0') return true;
  if(l.size() >= 2 && l[0] == '0' && l[1] == ' ') return true;
  if(l.size() >= 3 && l[0] == ' ' && l[1] == '0' && l[0] == ' ') return true;
  return false;
}

bool goSCACOPFData::
readinstance(const std::string& raw, const std::string& rop, const std::string& inl, const std::string& con)
{
  double MVAbase;
  StrVec buses, loads,  fixedbusshunts, generators, ntbranches, tbranches, switchedshunts;
  if(!readRAW(raw, MVAbase, buses, loads,  fixedbusshunts, generators, ntbranches, tbranches, switchedshunts)) {
    return false;
  }

  return true;
}

bool goSCACOPFData::
readRAW(const std::string& raw, double& MVAbase,
	StrVec& buses,  StrVec& loads, StrVec& fixedbusshunts,
	StrVec& generators, StrVec& ntbranches, StrVec& tbranches,
	StrVec& switchedshunts)
{
  ifstream rawfile(raw.c_str());
  if(!rawfile.is_open()) {
    log.printf(hovError, "failed to load raw file %s\n", raw.c_str());
    return false;
  }
  bool ret; string line; 
  ret = getline(rawfile, line); assert(ret);
  MVAbase = strtod(split(line, ',')[1].c_str(), NULL);

  //skip the next two lines
  ret = getline(rawfile, line); assert(ret);
  ret = getline(rawfile, line); assert(ret);

  string token; size_t pos; string delimiter=","; int i;

  //
  //bus data
  //
  //buses is a vector of 13 column vectors of string
  for(int i=0; i<=12; i++) buses.push_back(vector<string>());
  
  while(true) {
    ret = getline(rawfile, line); assert(ret);
    if(isEndOfSection(line)) break;
    
    for(i=0; i<=12; i++) {
      if( (pos = line.find(delimiter)) != string::npos ) {
	buses[i].push_back(line.substr(0,pos));
	line.erase(0, pos+delimiter.length());
      } else {
	buses[i].push_back(line);
      }
    }
    assert(i==13);
  }
#ifdef DEBUG
  int ngens=buses[0].size();
  for(i=1; i<=12; i++) {
    assert(buses[i]==ngens);
  }
#endif
  log.printf(hovSummary, "loaded data for %d buses\n", buses[0].size());

  //
  // load data
  //
  for(int i=0; i<14; i++) loads.push_back(vector<string>());
  while(true) {
    ret = getline(rawfile, line); assert(ret);
    if(isEndOfSection(line)) break;
    
    for(i=0; i<14; i++) {
      if( (pos = line.find(delimiter)) != string::npos ) {
	loads[i].push_back(line.substr(0,pos));
	line.erase(0, pos+delimiter.length());
      } else {
	loads[i].push_back(line);
      }
    }
    trim(loads[2].back()); //j. loads[:ID] = strip.(string.(loads[:ID]))
    assert(i==14);
  }
#ifdef DEBUG
  int nloads=loads[0].size();
  for(i=1; i<14; i++) {
    assert(loads[i]==nloads);
  }
#endif
  log.printf(hovSummary, "loaded data for %d loads\n", loads[0].size());

  //
  //fixed bus shunt data
  //
  for(int i=0; i<5; i++) fixedbusshunts.push_back(vector<string>());
  while(true) {
    ret = getline(rawfile, line); assert(ret);
    if(isEndOfSection(line)) break;
    
    for(i=0; i<5; i++) {
      if( (pos = line.find(delimiter)) != string::npos ) {
	fixedbusshunts[i].push_back(line.substr(0,pos));
	line.erase(0, pos+delimiter.length());
      } else {
	fixedbusshunts[i].push_back(line);
      }
    }
    assert(i==5);
  }
#ifdef DEBUG
  int nfbsh=fixedbusshunts[0].size();
  for(i=1; i<14; i++) {
    assert(fixedbusshunts[i]==nfbsh);
  }
#endif
  log.printf(hovSummary, "loaded data for %d fixed bus shunts\n", fixedbusshunts[0].size());

  //
  // generator data
  //
  for(int i=0; i<28; i++) generators.push_back(vector<string>());
    while(true) {
    ret = getline(rawfile, line); assert(ret);
    if(isEndOfSection(line)) break;
    
    for(i=0; i<28; i++) {
      if( (pos = line.find(delimiter)) != string::npos ) {
	generators[i].push_back(line.substr(0,pos));
	line.erase(0, pos+delimiter.length());
      } else {
	generators[i].push_back(line);
      }
    }
    assert(i==28);
  }
#ifdef DEBUG
  int ngens=generators[0].size();
  for(i=1; i<28; i++) {
    assert(generators[i]==ngens);
  }
#endif
  log.printf(hovSummary, "loaded data for %d generators\n", generators[0].size());
  return true;
}


}//end namespace
